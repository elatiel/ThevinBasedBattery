#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model TheveninBasedBattery
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Tue Oct 27 14:06:18 2020

  OutputCPUtime = true;
 */

#include <matrixop.h>
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DValue_M(struct 
  DymStruc0 tableID0_0, int  icol0_0, double  u0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int  extrapolation0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
DYMOLA_STATIC int   Modelica_Utilities_Strings_isEmpty(const char*  string0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
discrete output Real uMax "Maximum abscissa value in table";

external "C" uMax = ModelicaStandardTables_CombiTable1D_maximumAbscissa(tableID);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax;

  */
extern double (ModelicaStandardTables_CombiTable1D_maximumAbscissa)(void*);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax")
  {
    /* Declare outputs and temporaries */
    double   uMax0_0;
    uMax0_0=0;
    /* Start of real code */
    {
      uMax0_0 = (ModelicaStandardTables_CombiTable1D_maximumAbscissa)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return uMax0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
discrete output Real uMin "Minimum abscissa value in table";

external "C" uMin = ModelicaStandardTables_CombiTable1D_minimumAbscissa(tableID);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin;

  */
extern double (ModelicaStandardTables_CombiTable1D_minimumAbscissa)(void*);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin")
  {
    /* Declare outputs and temporaries */
    double   uMin0_0;
    uMin0_0=0;
    /* Start of real code */
    {
      uMin0_0 = (ModelicaStandardTables_CombiTable1D_minimumAbscissa)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return uMin0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable1DValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative=Modelica.Blocks.Tables.Internal.getDerTable1DValue, Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTable1DValue;

  */
extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , double );
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DValue_M(struct 
  DymStruc0 tableID0_0, int  icol0_0, double  u0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable1DValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
input Modelica.Blocks.Types.Extrapolation extrapolation(start = Modelica.Blocks.Types.Extrapolation.LastTwoPoints);
input Boolean verboseRead(start = true) "= true: Print info message; = false: No info message";
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init2(fileName, tableName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness, extrapolation, verboseRead);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
extern void* (ModelicaStandardTables_CombiTable1D_init2)(const char* , 
  const char* , double  const *, size_t, size_t, int  const *, size_t, int , int ,
   int );
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int  extrapolation0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init2)(fileName0_0, tableName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0, extrapolation0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.isEmpty
input String string;
output Boolean result "True, if string is empty";
protected 
Integer nextIndex;
Integer len;
public 
algorithm 
nextIndex := ModelicaStrings_skipWhiteSpace(string, 1);
len := ModelicaStrings_length(string);
if (len < 1 or nextIndex > len) then 
result := true;
else
result := false;
end if;
end Modelica.Utilities.Strings.isEmpty;

  */
DYMOLA_STATIC int   Modelica_Utilities_Strings_isEmpty(const char*  string0_0) {
  PushContext("Modelica.Utilities.Strings.isEmpty")
  {
    /* Declare outputs and temporaries */
    int   result0_0;
    int   nextIndex0_0;
    int   len0_0;
    result0_0=0;
    nextIndex0_0=0;
    len0_0=0;
    /* Start of real code */
      nextIndex0_0 = ModelicaStrings_skipWhiteSpace(string0_0, 1);
      len0_0 = ModelicaStrings_length(string0_0);
      if (len0_0 < 1 OR nextIndex0_0 > len0_0) {
        result0_0 = true;
      }
      else{
        result0_0 = false;
      }
    /* Output section */
    PopContext()
    return result0_0;
  }}
/* DSblock C-code: */

#define NX_    3
#define NX2_   1
#define NU_    0
#define NY_    2
#define NW_    51
#define NP_    19
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   2
#define MAXAuxStrLen_   500
#define NHash1_ 1370558354
#define NHash2_ -997046056
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    41
#define SizePre_ 0
#define SizeEq_ 5
#define SizeDelay_ 0
#define QNLmax_ 1
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 44
#define NGlobalHelpI_ 23
#ifndef NExternalObject_
#define NExternalObject_ 1
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="TheveninBasedBattery";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/bogodt2/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
DYNX(Y_,0) = CurrentClockTime;
if (DYNEvent) DYNX(Y_,1) += 1;

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,0) = 3060;
DYNX(W_,5) = false;
DYNX(W_,12) = false;
DYNX(W_,19) = false;
DYNX(W_,20) = false;
DYNX(W_,24) = 1;
DYNX(W_,34) = 2;
DYNX(W_,36) = false;
DYNX(W_,43) = false;
DYNX(W_,18) = 0.000326797385620915;
DYNX(W_,21) = 3;
#endif
DYNSetAuxString(did_, "tab", 0);
DYNSetAuxString(did_, "D:/Data/GitHub/ThevinBasedBattery/soc_to_u_bat_tookup.txt",
   1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,27) = 2;
DYNX(W_,26) = true;
DYNX(W_,28) = 1;
DYNX(W_,29) = 2;
DYNX(W_,30) = false;
DYNX(W_,35) = 0;
DYNX(W_,23) = 0;
DYNX(W_,48) = 0.0;
DYNX(W_,22) = false;
DYNX(W_,50) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,6) = DYNX(DP_,1);
AssertModelica(1+DYNX(DP_,2)*(DYNX(W_,6)-DYNX(DP_,1)) >= 1E-15,"1+R_0.alpha*(R_0.T-R_0.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,13) = DYNX(DP_,4);
AssertModelica(1+DYNX(DP_,5)*(DYNX(W_,13)-DYNX(DP_,4)) >= 1E-15,"1+R_tl.alpha*(R_tl.T-R_tl.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
InitialBoundSection
DYNX(DYNhelp,0) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(SOC_to_U_bat.fileName)")
  Modelica_Utilities_Strings_isEmpty("D:/Data/GitHub/ThevinBasedBattery/soc_to_u_bat_tookup.txt"));
PopModelContext();
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D((if SOC_to_U_bat.tableOnFile then SOC_to_U_bat.tableName else \"NoName\"), (if SOC_to_U_bat.tableOnFile and SOC_to_U_bat.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(SOC_to_U_bat.fileName) then SOC_to_U_bat.fileName else \"NoName\"), SOC_to_U_bat.table, SOC_to_U_bat.columns, SOC_to_U_bat.smoothness, SOC_to_U_bat.extrapolation, (if SOC_t...")
    Modelica_Blocks_Types_ExternalCombiTable1D_M(IF DYNX(W_,26) THEN "tab" ELSE 
    "NoName", IF DYNX(W_,26) AND (strcmp("D:/Data/GitHub/ThevinBasedBattery/soc_to_u_bat_tookup.txt",
     "NoName")!=0) AND  NOT DYNX(DYNhelp,0) THEN "D:/Data/GitHub/ThevinBasedBattery/soc_to_u_bat_tookup.txt"
     ELSE "NoName", RealTemporaryDense( (Real*)(0), 2, 0, 2), IntegerTemporaryDense( 
    &DYNX(W_,27), 1, 1), (Integer)(DYNX(W_,28)), (Integer)(DYNX(W_,29)), 
    (Integer)(IF DYNX(W_,26) THEN DYNX(DP_,8) ELSE false), 0, 1));
  DYNX(W_,33) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
DYNX(W_,31) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin(\nSOC_to_U_bat.tableID)")
  Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,33)))));
PopModelContext();
DYNX(W_,32) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax(\nSOC_to_U_bat.tableID)")
  Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,33)))));
PopModelContext();
DYNX(W_,37) = DYNX(DP_,12);
AssertModelica(1+DYNX(DP_,13)*(DYNX(W_,37)-DYNX(DP_,12)) >= 1E-15,
  "1+load.alpha*(load.T-load.T_ref) >= 1E-15", "Temperature outside scope of model!");
DYNX(W_,44) = DYNX(DP_,16);
AssertModelica(1+DYNX(DP_,17)*(DYNX(W_,44)-DYNX(DP_,16)) >= 1E-15,
  "1+R_ts.alpha*(R_ts.T-R_ts.T_ref) >= 1E-15", "Temperature outside scope of model!");
BoundParameterConstantSection
DYNX(W_,8) = DYNX(DP_,0)*(1+DYNX(DP_,2)*(DYNX(W_,6)-DYNX(DP_,1)));
DYNX(W_,46) = DYNX(DP_,15)*(1+DYNX(DP_,17)*(DYNX(W_,44)-DYNX(DP_,16)));
DYNX(W_,15) = DYNX(DP_,3)*(1+DYNX(DP_,5)*(DYNX(W_,13)-DYNX(DP_,4)));
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,10) = -0.0001;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(X_,1) = DYNX(DP_,7);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(X_,1) = DYNX(DP_,7);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
 /* Linear system of equations to solve. */
DYNX(W_,9) = RememberSimple_(DYNX(W_,9), 0);
SolveScalarLinearParametric( -DYNX(W_,15)," -R_tl.R_actual",  -DYNX(X_,0),
  " -C_tl.v", DYNX(W_,9),"R_tl.i");
 /* End of Equation Block */ 

DYNX(W_,25) = DYNX(DP_,9)*DYNX(DP_,11)+DYNX(DP_,10)*DYNX(X_,1);
DYNX(W_,4) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DValue(\nSOC_to_U_bat.tableID, \n1, \nSOC_to_U_bat.u[1])")
  Modelica_Blocks_Tables_Internal_getTable1DValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,33))), 1, DYNX(W_,25)));
PopModelContext();

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 7 common subexpressions used in 2 expressions */
/* Of the common subexpressions 7 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"R_0.i"};
const double nominal_[]={1};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 0, 1, 2, 3, 
  DYNX(DYNhelp,1), 41, DYNX(did_->helpvari_vec,0), 23);
NonLinearSystemSave(DYNX(X_,0), 0);
NonLinearSystemSave(DYNX(X_,2), 1);
NonLinearSystemSave(DYNX(W_,4), 2);
SetInitVectorNH(x__, 1, DYNX(W_,2), Remember_(DYNX(W_,2), 1));
Residues;
  DYNX(W_,1) = DYNX(W_,8)*DYNX(W_,2);
  DYNX(W_,10) = DYNX(W_,1)+DYNX(X_,2)+DYNX(X_,0)+DYNX(W_,4);
  if (NewParameters_) {
  DYNX(DYNhelp,42) = divinvGuarded(DYNX(DP_,14),"load.I_req");
  }
  DYNX(W_,40) =  -DYNX(DYNhelp,42)*DYNX(W_,10);
  DYNX(DYNhelp,43) = 1+DYNX(DP_,13)*(DYNX(W_,37)-DYNX(DP_,12));
  DYNX(W_,39) = DYNX(W_,40)*DYNX(DYNhelp,43);
SetVector(residue__, 1, DYNX(W_,10)+DYNX(W_,39)*DYNX(W_,2));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, DYNX(W_,39)+(1.0-DYNX(DYNhelp,42)*
  DYNX(DYNhelp,43)*DYNX(W_,2))*DYNX(W_,8));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 1, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,2) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,17) = DYNX(W_,2);
DYNX(W_,3) = DYNX(W_,1)+DYNX(W_,4);
DYNX(W_,11) = DYNX(W_,10)-DYNX(X_,0);
DYNX(W_,41) = DYNX(X_,2);
 /* Linear system of equations to solve. */
DYNX(W_,42) = RememberSimple_(DYNX(W_,42), 2);
SolveScalarLinearParametric( -DYNX(W_,46)," -R_ts.R_actual",  -DYNX(W_,41),
  " -R_ts.v", DYNX(W_,42),"R_ts.i");
 /* End of Equation Block */ 

DYNX(W_,16) = DYNX(W_,17)-DYNX(W_,9);
DYNX(W_,47) = DYNX(W_,17)-DYNX(W_,42);
DYNX(F_,1) = 0.000326797385620915*DYNX(W_,17);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 3);
SolveScalarLinearParametric( -DYNX(DP_,6)," -C_tl.C",  -DYNX(W_,16)," -C_tl.i", 
  DYNX(F_,0),"der(C_tl.v)");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(F_,2) = RememberSimple_(DYNX(F_,2), 4);
SolveScalarLinearParametric( -DYNX(DP_,18)," -C_ts.C",  -DYNX(W_,47)," -C_ts.i",
   DYNX(F_,2),"der(C_ts.v)");
 /* End of Equation Block */ 


AcceptedSection1

AcceptedSection2
DYNX(W_,7) = DYNX(W_,1)*DYNX(W_,2);
DYNX(W_,14) = DYNX(X_,0)*DYNX(W_,9);
DYNX(W_,38) =  -DYNX(W_,10)*DYNX(W_,17);
DYNX(W_,45) = DYNX(W_,41)*DYNX(W_,42);
DYNX(W_,49) = DYNX(W_,2)-DYNX(W_,17);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("C_bat", "", 3060, 0.0,0.0,0.0,0,513)
DeclareParameter("R_0.R", "Resistance at temperature T_ref [Ohm]", 0, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("R_0.T_ref", "Reference temperature [K|degC]", 1, 300.15, 0.0,\
1E+100,300.0,0,560)
DeclareParameter("R_0.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 2, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("R_0.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("R_0.i", "Current flowing from pin p to pin n [A]", 0.0, \
0.0,0.0,0.0,0,576)
DeclareVariable("R_0.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("R_0.p.i", "Current flowing into the pin [A]", "R_0.i", 1, 5, 2, 132)
DeclareVariable("R_0.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("R_0.n.i", "Current flowing into the pin [A]", "R_0.i", -1, 5, 2, 132)
DeclareVariable("R_0.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("R_0.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("R_0.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("R_0.T_heatPort", "Temperature of heatPort [K|degC]", "R_0.T", 1, 5,\
 6, 0)
DeclareVariable("R_0.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("R_tl.R", "Resistance at temperature T_ref [Ohm]", 3, 50, \
0.0,0.0,0.0,0,560)
DeclareParameter("R_tl.T_ref", "Reference temperature [K|degC]", 4, 300.15, 0.0,\
1E+100,300.0,0,560)
DeclareParameter("R_tl.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 5, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("R_tl.v", "Voltage drop of the two pins (= p.v - n.v) [V]", \
"C_tl.v", 1, 1, 0, 0)
DeclareVariable("R_tl.i", "Current flowing from pin p to pin n [A]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("R_tl.p.v", "Potential at the pin [V]", -0.0001, 0.0,0.0,0.0,0,520)
DeclareAlias2("R_tl.p.i", "Current flowing into the pin [A]", "R_tl.i", 1, 5, 9,\
 132)
DeclareVariable("R_tl.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("R_tl.n.i", "Current flowing into the pin [A]", "R_tl.i", -1, 5, 9,\
 132)
DeclareVariable("R_tl.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("R_tl.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("R_tl.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("R_tl.T_heatPort", "Temperature of heatPort [K|degC]", "R_tl.T", 1,\
 5, 13, 0)
DeclareVariable("R_tl.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareState("C_tl.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 0, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("C_tl.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("C_tl.i", "Current flowing from pin p to pin n [A]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("C_tl.p.v", "Potential at the pin [V]", "R_tl.p.v", 1, 5, 10, 4)
DeclareAlias2("C_tl.p.i", "Current flowing into the pin [A]", "C_tl.i", 1, 5, 16,\
 132)
DeclareAlias2("C_tl.n.v", "Potential at the pin [V]", "R_tl.n.v", 1, 5, 11, 4)
DeclareAlias2("C_tl.n.i", "Current flowing into the pin [A]", "C_tl.i", -1, 5, 16,\
 132)
DeclareParameter("C_tl.C", "Capacitance [F]", 6, 5000, 0.0,1E+100,0.0,0,560)
DeclareAlias2("I_bat.p.v", "Potential at the pin [V]", "R_tl.p.v", 1, 5, 10, 4)
DeclareVariable("I_bat.p.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,\
0.0,0,776)
DeclareAlias2("I_bat.n.v", "Potential at the pin [V]", "R_tl.p.v", 1, 5, 10, 4)
DeclareAlias2("I_bat.n.i", "Current flowing into the pin [A]", "I_bat.p.i", -1, 5,\
 17, 132)
DeclareAlias2("I_bat.i", "Current in the branch from p to n as output signal [A]",\
 "I_bat.p.i", 1, 5, 17, 0)
DeclareVariable("integrator.k", "Integrator gain [1]", 0.000326797385620915, \
0.0,0.0,0.0,0,513)
DeclareVariable("integrator.use_reset", "=true, if reset port enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("integrator.use_set", "=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("integrator.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("integrator.y_start", "Initial or guess value of output (= state) [C]",\
 7, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("integrator.u", "Connector of Real input signal [A]", "I_bat.p.i", 1,\
 5, 17, 0)
DeclareState("integrator.y", "Connector of Real output signal [C]", 1, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("integrator.der(y)", "der(Connector of Real output signal) [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("integrator.local_reset", "[:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,1539)
DeclareVariable("integrator.local_set", "", 0, 0.0,0.0,0.0,0,1537)
DeclareVariable("SOC_to_U_bat.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("SOC_to_U_bat.u[1]", "Connector of Real input signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("SOC_to_U_bat.y[1]", "Connector of Real output signals [V]", \
"R_0.n.v", 1, 5, 4, 0)
DeclareVariable("SOC_to_U_bat.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("SOC_to_U_bat.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 8, true, 0.0,0.0,0.0,0,562)
DeclareVariable("SOC_to_U_bat.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("SOC_to_U_bat.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,5.0,0.0,0,517)
DeclareVariable("SOC_to_U_bat.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("SOC_to_U_bat.verboseExtrapolation", "= true, if warning messages are to be printed if table input is outside the definition range [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("SOC_to_U_bat.u_min", "Minimum abscissa value defined in table",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("SOC_to_U_bat.u_max", "Maximum abscissa value defined in table",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("SOC_to_U_bat.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,\
0,2565)
DeclareVariable("Sum.nin", "Number of inputs [:#(type=Integer)]", 2, 0.0,0.0,0.0,\
0,517)
DeclareAlias2("Sum.u[1]", "Connector of Real input signals", "SOC_init.k", 1, 7,\
 11, 0)
DeclareAlias2("Sum.u[2]", "Connector of Real input signals [C]", "integrator.y", 1,\
 1, 1, 0)
DeclareAlias2("Sum.y", "Connector of Real output signal", "SOC_to_U_bat.u[1]", 1,\
 5, 25, 0)
DeclareParameter("Sum.k[1]", "Optional: sum coefficients", 9, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("Sum.k[2]", "Optional: sum coefficients", 10, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("SOC_init.k", "Constant output value", 11, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("SOC_init.y", "Connector of Real output signal", "SOC_init.k", 1, 7,\
 11, 0)
DeclareParameter("load.T_ref", "Reference temperature [K|degC]", 12, 300.15, 0.0,\
1E+100,300.0,0,560)
DeclareParameter("load.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 13, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("load.v", "Voltage drop of the two pins (= p.v - n.v) [V]", \
"R_tl.p.v", -1, 5, 10, 0)
DeclareAlias2("load.i", "Current flowing from pin p to pin n [A]", "I_bat.p.i", 1,\
 5, 17, 0)
DeclareVariable("load.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("load.p.i", "Current flowing into the pin [A]", "I_bat.p.i", 1, 5,\
 17, 132)
DeclareAlias2("load.n.v", "Potential at the pin [V]", "R_tl.p.v", 1, 5, 10, 4)
DeclareAlias2("load.n.i", "Current flowing into the pin [A]", "I_bat.p.i", -1, 5,\
 17, 132)
DeclareVariable("load.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("load.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("load.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("load.T_heatPort", "Temperature of heatPort [K|degC]", "load.T", 1,\
 5, 37, 0)
DeclareVariable("load.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("load.R", "[Ohm]", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("load.I_req", "[A]", 14, 2, 0.0,0.0,0.0,0,560)
DeclareParameter("R_ts.R", "Resistance at temperature T_ref [Ohm]", 15, 50, \
0.0,0.0,0.0,0,560)
DeclareParameter("R_ts.T_ref", "Reference temperature [K|degC]", 16, 300.15, 0.0,\
1E+100,300.0,0,560)
DeclareParameter("R_ts.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 17, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("R_ts.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("R_ts.i", "Current flowing from pin p to pin n [A]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("R_ts.p.v", "Potential at the pin [V]", "R_tl.n.v", 1, 5, 11, 4)
DeclareAlias2("R_ts.p.i", "Current flowing into the pin [A]", "R_ts.i", 1, 5, 42,\
 132)
DeclareAlias2("R_ts.n.v", "Potential at the pin [V]", "R_0.p.v", 1, 5, 3, 4)
DeclareAlias2("R_ts.n.i", "Current flowing into the pin [A]", "R_ts.i", -1, 5, 42,\
 132)
DeclareVariable("R_ts.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("R_ts.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("R_ts.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("R_ts.T_heatPort", "Temperature of heatPort [K|degC]", "R_ts.T", 1,\
 5, 44, 0)
DeclareVariable("R_ts.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareState("C_ts.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 2, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("C_ts.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("C_ts.i", "Current flowing from pin p to pin n [A]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("C_ts.p.v", "Potential at the pin [V]", "R_tl.n.v", 1, 5, 11, 4)
DeclareAlias2("C_ts.p.i", "Current flowing into the pin [A]", "C_ts.i", 1, 5, 47,\
 132)
DeclareAlias2("C_ts.n.v", "Potential at the pin [V]", "R_0.p.v", 1, 5, 3, 4)
DeclareAlias2("C_ts.n.i", "Current flowing into the pin [A]", "C_ts.i", -1, 5, 47,\
 132)
DeclareParameter("C_ts.C", "Capacitance [F]", 18, 500, 0.0,1E+100,0.0,0,560)
DeclareVariable("GND.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("GND.p.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,\
0,776)
DeclareAlias2("signalVoltage.p.v", "Potential at the pin [V]", "R_0.n.v", 1, 5, 4,\
 4)
DeclareAlias2("signalVoltage.p.i", "Current flowing into the pin [A]", "R_0.i", 1,\
 5, 2, 132)
DeclareVariable("signalVoltage.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("signalVoltage.n.i", "Current flowing into the pin [A]", "R_0.i", -1,\
 5, 2, 132)
DeclareAlias2("signalVoltage.v", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "R_0.n.v", 1, 5, 4, 0)
DeclareAlias2("signalVoltage.i", "Current flowing from pin p to pin n [A]", \
"R_0.i", 1, 5, 2, 0)
DeclareOutput("CPUtime", "[s]", 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("EventCounter", "", 1, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,2), 0.0, 1);
DoRemember_(DYNX(W_,9), 0.0, 0);
DoRemember_(DYNX(W_,42), 0.0, 2);
DoRemember_(DYNX(F_,0), 0.0, 3);
DoRemember_(DYNX(F_,2), 0.0, 4);
EndEqBlock
EndDataBlock
